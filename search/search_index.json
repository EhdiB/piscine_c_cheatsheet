{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"BEGINNER_C_PATTERN_SHEET/","title":"Beginner C Pattern Sheet (Piscine Edition)","text":""},{"location":"BEGINNER_C_PATTERN_SHEET/#introduction-what-is-this-document","title":"\ud83d\udcd6 Introduction: What Is This Document?","text":""},{"location":"BEGINNER_C_PATTERN_SHEET/#who-is-this-for","title":"Who Is This For?","text":"<p>This guide is designed for absolute beginners starting their first 2 weeks of the 42 Piscine (a 26-day intensive coding bootcamp). If you: - Have never written C code before - Are learning programming for the first time - Need help understanding basic C concepts - Want to see patterns used in 42 exercises</p> <p>Then this document is for you!</p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#what-this-document-covers","title":"What This Document Covers","text":"<p>This is a practical, pattern-based learning guide that teaches you:</p> <ol> <li>Basic C syntax (variables, loops, conditionals, functions)</li> <li>How to structure C files for 42 exercises</li> <li>String manipulation (the most common task in early exercises)</li> <li>Pointers (explained step-by-step with visual examples)</li> <li>Common code patterns you'll reuse constantly</li> <li>How to avoid beginner mistakes</li> </ol> <p>Everything is based on actual exercises from the first 2 weeks of piscine (C00, C01, C02, C03 modules).</p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#what-this-document-does-not-cover","title":"What This Document Does NOT Cover","text":"<p>This is not a complete C programming textbook. It does not cover: - Advanced topics (linked lists, file I/O, system calls beyond <code>write()</code>) - Memory allocation (<code>malloc</code>/<code>free</code>) - not needed in first 2 weeks - Header files (<code>.h</code> files) - covered briefly at the end as \"next steps\" - Complex data structures - Full C language reference</p> <p>Focus: Practical patterns for solving 42 piscine exercises in your first 2 weeks.</p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#how-to-use-this-document","title":"How to Use This Document","text":"<ol> <li>Read sections in order - concepts build on each other</li> <li>Keep it open while coding - use as a quick reference</li> <li>Study the examples - they're from real exercises</li> <li>Practice the patterns - try modifying the code examples</li> <li>Check the glossary - if you see an unfamiliar term, look it up</li> </ol>"},{"location":"BEGINNER_C_PATTERN_SHEET/#about-the-examples","title":"About the Examples","text":"<p>All code examples in this document come from analyzing actual exercise solutions from a 42 piscine repository (a collection of exercise files). The patterns shown are what you'll actually use to solve similar problems.</p> <p>Note: Some examples may contain bugs - we'll point these out so you can learn from mistakes!</p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#quick-lexicon-glossary","title":"\ud83d\udcda Quick Lexicon (Glossary)","text":"<p>Before you start, here are key terms you'll encounter:</p> Term Definition 42 / 42 Piscine A 26-day intensive coding bootcamp where you learn C programming through daily exercises Repository (repo) A folder containing code files - in this case, exercise solutions organized by module (C00, C01, etc.) Module A group of related exercises (e.g., C00 = basic output, C01 = pointers introduction) Exercise A single programming task (e.g., \"write a function that prints a character\") Function A reusable block of code that performs a specific task Variable A named storage location that holds a value (like a labeled box) Pointer A variable that stores a memory address (like a street address) String A sequence of characters (text) in C, always ending with <code>'\\0'</code> Array A collection of items stored in consecutive memory locations NUL terminator The <code>'\\0'</code> character that marks the end of a string Dereference Using <code>*</code> to get the value at a memory address Address-of Using <code>&amp;</code> to get the memory address of a variable Compile Converting your C code into an executable program Syntax The rules for writing valid C code (like grammar for a language) Header file A file (<code>.h</code>) that declares functions for use in other files Include Adding code from another file using <code>#include</code> Function signature The declaration showing return type, name, and parameters Parameter A value passed to a function Return value The result a function gives back Loop Code that repeats until a condition is met Conditional Code that runs only if a condition is true (<code>if</code>/<code>else</code>) Index A number used to access a specific position in an array/string Buffer A temporary storage area in memory Buffer overflow Writing past the end of allocated memory (dangerous bug) NULL pointer A pointer that doesn't point to anything (value: <code>NULL</code>) Undefined behavior Code that might work sometimes but isn't guaranteed (dangerous) ASCII A system where each character has a number (e.g., 'A' = 65) File descriptor A number representing an open file/stream (1 = screen output) Stdout Standard output - where your program prints (usually the screen) <p>Don't worry if you don't understand all terms yet - they'll be explained as you read!</p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#a-file-anatomy","title":"A. File Anatomy","text":""},{"location":"BEGINNER_C_PATTERN_SHEET/#what-goes-in-a-c-file","title":"What Goes in a <code>.c</code> File","text":"<p>What is a <code>.c</code> file? A <code>.c</code> file is a source code file containing C programming code. It's the file you write your program in, which gets compiled (converted) into an executable program.</p> <p>Every <code>.c</code> file in this repository (collection of exercise files) follows this structure:</p> <pre><code>/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   filename.c                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: author &lt;email@42.fr&gt;                         +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: YYYY/MM/DD HH:MM:SS by author            #+#    #+#             */\n/*   Updated: YYYY/MM/DD HH:MM:SS by author            ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n#include &lt;unistd.h&gt;\n\nvoid    ft_function_name(parameters)\n{\n    // Your code here\n}\n</code></pre> <p>Key points: - Header block: Required 42-style header (author, dates, etc.) - a comment block at the top of every file - Includes: At the top, after header - <code>#include</code> statements that add library functions - Function: One main function matching the filename - the code that does the work - Style: Tabs (not spaces), braces on new lines - formatting rules required by 42</p> <p>Minimal example:</p> <pre><code>#include &lt;unistd.h&gt;\n\nvoid    ft_hello(void)\n{\n    write(1, \"Hello\", 5);\n}\n</code></pre>"},{"location":"BEGINNER_C_PATTERN_SHEET/#b-importing-includes","title":"B. Importing / Includes","text":""},{"location":"BEGINNER_C_PATTERN_SHEET/#what-an-include-is","title":"What an Include Is","text":"<p>What is <code>#include</code>? <code>#include</code> is a preprocessor directive (special instruction) that copies code from another file into yours before compilation. Think of it like importing a toolbox - you're adding tools (functions) you can use.</p> <pre><code>#include &lt;unistd.h&gt;  // Gives you write() function\n</code></pre> <p>What is a library? A library is a collection of pre-written functions you can use. <code>&lt;unistd.h&gt;</code> is a standard library that provides the <code>write()</code> function for output.</p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#headers-observed-in-this-repository","title":"Headers Observed in This Repository","text":"<p>What is a header? A header file (<code>.h</code> file) contains declarations of functions. When you <code>#include</code> it, you're telling your program \"these functions exist and you can use them.\"</p> Header Purpose Evidence When to Use <code>&lt;unistd.h&gt;</code> Provides <code>write()</code> function Used in all files Always - for output <code>&lt;stdio.h&gt;</code> Provides <code>printf()</code>, etc. Only in commented test code Likely forbidden in submissions <code>&lt;string.h&gt;</code> String functions Found once (<code>c_03/ex04/ft_strstr.c:14</code>) Likely mistake - forbidden <p>Rule of thumb: Use <code>&lt;unistd.h&gt;</code> for <code>write()</code>. Avoid <code>&lt;stdio.h&gt;</code> (use <code>write()</code> instead of <code>printf()</code>).</p> <p>Example:</p> <pre><code>#include &lt;unistd.h&gt;  // Good - needed for write()\n\nvoid    ft_example(void)\n{\n    write(1, \"Hello\", 5);  // write() comes from unistd.h\n}\n</code></pre>"},{"location":"BEGINNER_C_PATTERN_SHEET/#c-variables-types-beginner-friendly","title":"C. Variables &amp; Types (Beginner-Friendly)","text":""},{"location":"BEGINNER_C_PATTERN_SHEET/#basic-types-youll-use","title":"Basic Types You'll Use","text":"<p>What is a type? A type tells the computer what kind of data a variable can hold and how much memory it needs.</p> Type Stores Example Size <code>int</code> Whole numbers (integers) <code>42</code>, <code>-5</code>, <code>0</code> Usually 4 bytes <code>char</code> Single character <code>'a'</code>, <code>'0'</code>, <code>'\\0'</code> 1 byte <code>char*</code> String (pointer to characters) <code>\"Hello\"</code>, <code>str</code> 8 bytes (pointer) <p>What is a byte? A byte is a unit of memory. One byte can store one character. Larger types use more bytes.</p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#declaration-initialization","title":"Declaration + Initialization","text":"<p>What is declaration? Declaration means telling the computer \"I want a variable with this name and type.\" What is initialization? Initialization means giving a variable its first value.</p> <p>Declare then assign:</p> <pre><code>int age;\nage = 25;\n</code></pre> <p>Declare and initialize:</p> <pre><code>int age = 25;\nchar    c = 'a';\nchar    *str = \"Hello\";\n</code></pre> <p>Multiple variables:</p> <pre><code>int i;\nint j;\nint k;\n\n// Or:\nint i, j, k;\n</code></pre>"},{"location":"BEGINNER_C_PATTERN_SHEET/#common-mistakes","title":"Common Mistakes","text":"<p>1. Uninitialized variable:</p> <pre><code>int i;  // Wrong: Value is garbage\nwhile (i &lt; 10)  // Undefined behavior!\n\n// Fix:\nint i = 0;\nwhile (i &lt; 10)\n</code></pre> <p>2. Wrong type:</p> <pre><code>char    c = 65;  // Works, but confusing\nchar    c = 'A';  // Better - same value (65)\n</code></pre> <p>3. Mixing signed/unsigned:</p> <pre><code>int     len = -1;\nunsigned int    size = 10;\nif (len &lt; size)  // -1 becomes huge unsigned number!\n\n// Fix: Use consistent types\nint len = -1;\nint size = 10;\n</code></pre>"},{"location":"BEGINNER_C_PATTERN_SHEET/#d-loops-patterns-youll-use-constantly","title":"D. Loops (Patterns You'll Use Constantly)","text":""},{"location":"BEGINNER_C_PATTERN_SHEET/#while-loop-template-especially-for-strings","title":"while Loop Template (Especially for Strings)","text":"<p>What is a loop? A loop repeats code multiple times until a condition becomes false.</p> <p>Most common pattern in the repository:</p> <pre><code>int i;\n\ni = 0;\nwhile (str[i] != '\\0')\n{\n    // Do something with str[i]\n    i++;\n}\n</code></pre> <p>Why this works: Strings end with <code>'\\0'</code>. Loop until you hit it.</p> <p>Example (from the repository):</p> <pre><code>void    ft_putstr(char *str)\n{\n    int i;\n\n    i = 0;\n    while (str[i] != '\\0')  // Loop until end of string\n    {\n        write(1, &amp;str[i], 1);\n        i++;  // Move to next character\n    }\n}\n</code></pre>"},{"location":"BEGINNER_C_PATTERN_SHEET/#for-loop-template-if-used","title":"for Loop Template (If Used)","text":"<p>Less common in the repository, but useful:</p> <pre><code>for (initialization; condition; increment)\n{\n    // Body\n}\n</code></pre> <p>Example:</p> <pre><code>int i;\n\nfor (i = 0; i &lt; 10; i++)\n{\n    write(1, &amp;i, 1);\n}\n</code></pre> <p>Equivalent while:</p> <pre><code>int i;\n\ni = 0;\nwhile (i &lt; 10)\n{\n    write(1, &amp;i, 1);\n    i++;\n}\n</code></pre> <p>Repository preference: <code>while</code> loops are more common in these exercises.</p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#common-loop-mistakes","title":"Common Loop Mistakes","text":"<p>1. Off-by-one:</p> <pre><code>// Wrong: Goes one too far\nint i = 0;\nwhile (i &lt;= size)  // Accesses arr[size] (out of bounds!)\n{\n    arr[i] = 0;\n    i++;\n}\n\n// Correct:\nint i = 0;\nwhile (i &lt; size)  // Stops at size-1\n{\n    arr[i] = 0;\n    i++;\n}\n</code></pre> <p>2. Infinite loop (forgetting increment):</p> <pre><code>// Wrong: i never changes!\nint i = 0;\nwhile (i &lt; 10)\n{\n    write(1, \"loop\", 4);\n    // Forgot i++!\n}\n\n// Correct:\nint i = 0;\nwhile (i &lt; 10)\n{\n    write(1, \"loop\", 4);\n    i++;  // Don't forget!\n}\n</code></pre>"},{"location":"BEGINNER_C_PATTERN_SHEET/#e-conditionals","title":"E. Conditionals","text":""},{"location":"BEGINNER_C_PATTERN_SHEET/#if-else-basics","title":"if / else Basics","text":"<pre><code>if (condition)\n{\n    // Do this if true\n}\nelse\n{\n    // Do this if false\n}\n</code></pre> <p>Common patterns in the repository:</p> <p>1. Simple check:</p> <pre><code>if (n &lt; 0)\n    write(1, \"N\", 1);\nelse\n    write(1, \"P\", 1);\n</code></pre> <p>2. Multiple conditions:</p> <pre><code>if (c &gt;= 'a' &amp;&amp; c &lt;= 'z')  // AND\n    return (1);\nif (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')  // OR (separate if)\n    return (1);\nreturn (0);\n</code></pre> <p>3. Nested if:</p> <pre><code>if (nb == -2147483648)\n{\n    write(1, \"-2147483648\", 11);\n}\nelse if (nb &lt; 0)\n{\n    write(1, \"-\", 1);\n    nb = -nb;\n}\n</code></pre>"},{"location":"BEGINNER_C_PATTERN_SHEET/#common-comparison-patterns","title":"Common Comparison Patterns","text":"Pattern Meaning Example <code>==</code> Equal <code>if (x == 5)</code> <code>!=</code> Not equal <code>if (str[i] != '\\0')</code> <code>&lt;</code> Less than <code>if (i &lt; size)</code> <code>&lt;=</code> Less or equal <code>if (c &lt;= 'z')</code> <code>&gt;</code> Greater than <code>if (x &gt; 0)</code> <code>&gt;=</code> Greater or equal <code>if (c &gt;= 'a')</code> <code>&amp;&amp;</code> AND <code>if (x &gt; 0 &amp;&amp; x &lt; 10)</code> <code>\\|\\|</code> OR <code>if (c == 'a' \\|\\| c == 'A')</code> <p>Character range checks (very common):</p> <pre><code>if (c &gt;= 'a' &amp;&amp; c &lt;= 'z')  // Lowercase letter\nif (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')  // Uppercase letter\nif (c &gt;= '0' &amp;&amp; c &lt;= '9')  // Digit\n</code></pre>"},{"location":"BEGINNER_C_PATTERN_SHEET/#f-functions","title":"F. Functions","text":""},{"location":"BEGINNER_C_PATTERN_SHEET/#function-signature-basics","title":"Function Signature Basics","text":"<p>What is a function signature? A function signature is the declaration that shows: - Return type: What kind of value the function gives back (or <code>void</code> if nothing) - Function name: What you call it - Parameters: What values you pass to it</p> <pre><code>return_type function_name(parameter_type parameter_name)\n{\n    // Body - the code that does the work\n    return (value);  // If return_type is not void\n}\n</code></pre> <p>What is a parameter? A parameter (also called \"argument\") is a value you pass to a function when you call it.</p> <p>Example:</p> <pre><code>int ft_strlen(char *str)  // Returns int, takes char* parameter\n{\n    int i;\n\n    i = 0;\n    while (str[i] != '\\0')\n        i++;\n    return (i);  // Return the length\n}\n</code></pre> <p>Return types: - <code>void</code> = returns nothing - <code>int</code> = returns a number - <code>char*</code> = returns a pointer (often the string you modified)</p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#passing-by-value-copy","title":"Passing by Value (Copy)","text":"<p>By value (copy):</p> <pre><code>void    ft_add_one(int n)\n{\n    n = n + 1;  // Only changes local copy\n}\n\nint main(void)\n{\n    int x = 5;\n    ft_add_one(x);\n    // x is still 5! (not changed)\n}\n</code></pre> <p>Why this happens: Function gets a copy of the value. Changes don't affect original.</p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#write-small-helpers-pattern","title":"Write Small Helpers Pattern","text":"<p>Observed in the repository: Functions call other helper functions.</p> <p>Example:</p> <pre><code>void    ft_putchar(char c)  // Helper\n{\n    write(1, &amp;c, 1);\n}\n\nvoid    ft_putnbr(int nb)  // Uses helper\n{\n    if (nb &gt;= 10)\n    {\n        ft_putnbr(nb / 10);\n        ft_putchar((nb % 10) + '0');  // Uses helper\n    }\n    else\n        ft_putchar(nb + '0');\n}\n</code></pre> <p>Why: Break problems into smaller pieces. Reuse code.</p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#g-strings-nul-terminated","title":"G. Strings (NUL-Terminated)","text":""},{"location":"BEGINNER_C_PATTERN_SHEET/#what-a-c-string-is","title":"What a C String Is","text":"<p>What is a string? A string is text - a sequence of characters. In C, a string is an array of characters ending with <code>'\\0'</code> (NUL terminator).</p> <p>What is an array? An array is a collection of items stored in consecutive memory locations. You access items by their position (index).</p> <pre><code>char    str[] = \"Hello\";\n// Actually: ['H', 'e', 'l', 'l', 'o', '\\0']\n//           [ 0,   1,   2,   3,   4,   5  ]\n</code></pre> <p>Key point: The <code>'\\0'</code> (NUL terminator) marks the end of the string. It's not printed, but must be there. Without it, the computer doesn't know where the string ends!</p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#how-to-traverse-safely","title":"How to Traverse Safely","text":"<p>What is traversing? Traversing means going through each element of a string or array, one by one.</p> <p>Standard pattern (from the repository):</p> <pre><code>int i;\n\ni = 0;\nwhile (str[i] != '\\0')  // Stop at terminator\n{\n    // Process str[i]\n    i++;\n}\n</code></pre> <p>Why safe: Stops at <code>'\\0'</code>, won't go past end.</p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#typical-edge-cases","title":"Typical Edge Cases","text":"<p>1. NULL pointer: What is NULL? <code>NULL</code> is a special value meaning \"this pointer doesn't point to anything.\" Trying to use a NULL pointer crashes your program.</p> <pre><code>// Crashes if str is NULL:\nint i = 0;\nwhile (str[i] != '\\0')  // Dereferences NULL! (tries to access invalid memory)\n\n// Check first (if required by exercise):\nif (str == NULL)\n    return (0);\nint i = 0;\nwhile (str[i] != '\\0')\n</code></pre> <p>2. Empty string:</p> <pre><code>char    *str = \"\";  // Contains only '\\0'\n// Length is 0, but str[0] == '\\0' is true\n</code></pre> <p>3. Missing terminator:</p> <pre><code>char    arr[5] = {'H', 'e', 'l', 'l', 'o'};  // No '\\0'!\n// This is NOT a valid string - undefined behavior when reading\n\n// Fix:\nchar    arr[6] = {'H', 'e', 'l', 'l', 'o', '\\0'};\n// Or:\nchar    arr[] = \"Hello\";  // Automatically includes '\\0'\n</code></pre>"},{"location":"BEGINNER_C_PATTERN_SHEET/#h-pointers-expanded-step-by-step","title":"H. Pointers (EXPANDED - Step by Step)","text":"<p>This is where many beginners get stuck. Read this carefully!</p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#what-is-a-pointer-the-address-analogy","title":"What is a Pointer? (The Address Analogy)","text":"<p>What is a pointer? A pointer is a variable that stores a memory address instead of a value. Think of it as a piece of paper with a street address written on it, rather than the house itself.</p> <p>What is memory? Memory (RAM) is where your computer stores data while your program runs. Think of memory like a street with numbered houses (addresses). A variable is a house with a value inside. A pointer is a piece of paper with the house address written on it.</p> <pre><code>Memory (the street):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Address \u2502  1000   \u2502  1004   \u2502  1008   \u2502\n\u2502 Value   \u2502   42    \u2502   ???   \u2502   ???   \u2502\n\u2502 Name    \u2502  value  \u2502         \u2502   ptr   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>In code:</p> <pre><code>int value = 42;      // House at address 1000 contains 42\nint *ptr = &amp;value;   // ptr is a paper saying \"address 1000\"\n</code></pre>"},{"location":"BEGINNER_C_PATTERN_SHEET/#the-two-operators-and","title":"The Two Operators: <code>&amp;</code> and <code>*</code>","text":"<p>What is an operator? An operator is a symbol that performs an operation (like <code>+</code> for addition).</p> <p><code>&amp;</code> (address-of operator): \"Give me the address of this variable\" What does <code>&amp;</code> do? The <code>&amp;</code> operator gets the memory address where a variable is stored.</p> <pre><code>int x = 5;\nint *ptr = &amp;x;  // ptr now holds the address of x\n</code></pre> <p><code>*</code> (dereference operator): \"Go to this address and get/change the value\" What does <code>*</code> do? The <code>*</code> operator (when used with a pointer) follows the address to get or modify the value stored there. This is called dereferencing.</p> <pre><code>int x = 5;\nint *ptr = &amp;x;  // ptr points to x\n*ptr = 10;      // Go to address in ptr, change value to 10\n// Now x is 10!\n</code></pre>"},{"location":"BEGINNER_C_PATTERN_SHEET/#visual-step-by-step-example","title":"Visual Step-by-Step Example","text":"<pre><code>int value = 42;\nint *ptr = &amp;value;\n*ptr = 100;\n</code></pre> <p>Step 1: <code>int value = 42;</code></p> <pre><code>Memory:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Address: 1000\n\u2502 Value:   42\n\u2502 Name:    value\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Step 2: <code>int *ptr = &amp;value;</code></p> <pre><code>Memory:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Address: 1000 \u2502 Address: 2000\n\u2502 Value:   42   \u2502 Value:   1000  \u2190 address of value!\n\u2502 Name:    value\u2502 Name:    ptr\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 (points to)\n</code></pre> <p>Step 3: <code>*ptr = 100;</code></p> <pre><code>Memory:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Address: 1000 \u2502 Address: 2000\n\u2502 Value:   100  \u2502 Value:   1000\n\u2502 Name:    value\u2502 Name:    ptr\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   \u2191 Changed!   (still points here)\n</code></pre>"},{"location":"BEGINNER_C_PATTERN_SHEET/#why-do-we-need-pointers","title":"Why Do We Need Pointers?","text":"<p>Why use pointers? Pointers let functions modify variables that are passed to them. Without pointers, functions only get copies of values.</p> <p>Problem: Functions can't modify variables passed by value.</p> <pre><code>void    ft_change(int n)\n{\n    n = 100;  // Only changes local copy\n}\n\nint main(void)\n{\n    int x = 5;\n    ft_change(x);\n    // x is still 5! \u274c\n}\n</code></pre> <p>Solution: Pass the address (pointer), so function can modify original.</p> <pre><code>void    ft_change(int *n)  // Receives address\n{\n    *n = 100;  // Go to address, change value\n}\n\nint main(void)\n{\n    int x = 5;\n    ft_change(&amp;x);  // Pass address of x\n    // x is now 100! \u2705\n}\n</code></pre>"},{"location":"BEGINNER_C_PATTERN_SHEET/#first-pointer-exercise-pattern-from-the-repository","title":"First Pointer Exercise Pattern (from the repository)","text":"<p><code>ft_ft</code> - Simplest pointer example:</p> <pre><code>void    ft_ft(int *nbr)  // Receives pointer (address)\n{\n    *nbr = 42;  // Dereference: go to address, set value to 42\n}\n</code></pre> <p>How to call it:</p> <pre><code>int number = 0;\nft_ft(&amp;number);  // Pass address of number\n// number is now 42!\n</code></pre> <p>What happens: 1. <code>&amp;number</code> gives address of <code>number</code> 2. Function receives that address in <code>nbr</code> 3. <code>*nbr = 42</code> goes to that address and changes value 4. Original <code>number</code> is now 42</p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#swap-pattern-classic-pointer-example","title":"Swap Pattern (Classic Pointer Example)","text":"<p>From the repository: <code>c_01/ex02/ft_swap.c</code></p> <pre><code>void    ft_swap(int *a, int *b)\n{\n    int temp;\n\n    temp = *a;   // Save value at address a\n    *a = *b;     // Copy value from b to a\n    *b = temp;   // Copy saved value to b\n}\n</code></pre> <p>Visual explanation:</p> <pre><code>Before swap:\na \u2192 [5]  (address 1000)\nb \u2192 [10] (address 1004)\n\nAfter temp = *a:\ntemp = 5\na \u2192 [5]\nb \u2192 [10]\n\nAfter *a = *b:\ntemp = 5\na \u2192 [10]  \u2190 changed!\nb \u2192 [10]\n\nAfter *b = temp:\ntemp = 5\na \u2192 [10]\nb \u2192 [5]   \u2190 changed!\n</code></pre>"},{"location":"BEGINNER_C_PATTERN_SHEET/#pointers-and-strings","title":"Pointers and Strings","text":"<p>Important: In C, strings are pointers to characters!</p> <pre><code>char    *str = \"Hello\";\n// str is a pointer to the first character 'H'\n</code></pre> <p>Why this works: - <code>str[0]</code> is same as <code>*str</code> (first character) - <code>str[1]</code> is same as <code>*(str + 1)</code> (next character) - String functions receive <code>char *</code> (pointer to first char)</p> <p>Example from repo:</p> <pre><code>void    ft_putstr(char *str)  // Receives pointer to first char\n{\n    int i;\n\n    i = 0;\n    while (str[i] != '\\0')  // Can use indexing with pointer\n    {\n        write(1, &amp;str[i], 1);\n        i++;\n    }\n}\n</code></pre>"},{"location":"BEGINNER_C_PATTERN_SHEET/#common-pointer-mistakes-beginners-make-these","title":"Common Pointer Mistakes (Beginners Make These!)","text":"<p>1. Forgetting <code>&amp;</code> when passing address:</p> <pre><code>void    ft_change(int *n)\n{\n    *n = 100;\n}\n\nint main(void)\n{\n    int x = 5;\n    ft_change(x);  // \u274c Wrong! Passes value, not address\n    // Compiler error or crash\n\n    ft_change(&amp;x);  // \u2705 Correct! Passes address\n}\n</code></pre> <p>2. Using <code>*</code> when you shouldn't:</p> <pre><code>int x = 5;\nint *ptr = &amp;x;\n\nint y = *ptr;   // \u2705 Correct: get value\nint y = ptr;    // \u274c Wrong: assigns address (wrong type)\n</code></pre> <p>3. Dereferencing NULL or uninitialized pointer:</p> <pre><code>int *ptr;        // \u274c Not initialized!\n*ptr = 5;        // Crash! ptr points to random memory\n\nint *ptr = NULL;  // \u274c Points to nothing\n*ptr = 5;        // Crash! Can't write to NULL\n\n// \u2705 Fix:\nint *ptr;\nint value = 5;\nptr = &amp;value;    // Now ptr points to valid memory\n*ptr = 10;       // Safe!\n</code></pre> <p>4. Confusing <code>*</code> in declaration vs usage:</p> <pre><code>int *ptr;        // Declaration: * means \"pointer to int\"\n*ptr = 5;        // Usage: * means \"dereference (get value)\"\n</code></pre> <p>5. Wrong type when passing:</p> <pre><code>void    ft_swap(int *a, int *b)  // Expects pointers\n{\n    // ...\n}\n\nint main(void)\n{\n    int x = 5, y = 10;\n    ft_swap(x, y);     // \u274c Wrong: passing values\n    ft_swap(&amp;x, &amp;y);   // \u2705 Correct: passing addresses\n}\n</code></pre>"},{"location":"BEGINNER_C_PATTERN_SHEET/#pointer-declaration-patterns","title":"Pointer Declaration Patterns","text":"<p>Single pointer:</p> <pre><code>int *ptr;        // Pointer to int\nchar    *str;       // Pointer to char (string)\n</code></pre> <p>Multiple pointers (each needs *):</p> <pre><code>int *a, *b, *c;  // Three pointers to int\n// NOT: int *a, b, c;  (only a is pointer!)\n</code></pre> <p>Pointer to pointer (advanced - seen in <code>ft_ultimate_ft</code>):</p> <pre><code>int **ptr;       // Pointer to pointer to int\n// Used when you need to modify a pointer itself\n</code></pre>"},{"location":"BEGINNER_C_PATTERN_SHEET/#quick-reference-pointer-rules","title":"Quick Reference: Pointer Rules","text":"Situation Syntax Meaning Declare pointer <code>int *ptr;</code> <code>ptr</code> is a pointer to int Get address <code>&amp;variable</code> Address of <code>variable</code> Get value <code>*ptr</code> Value at address in <code>ptr</code> Change value <code>*ptr = 5;</code> Set value at address to 5 Pass to function <code>func(&amp;x)</code> Pass address of <code>x</code> Receive in function <code>void func(int *n)</code> Function receives address"},{"location":"BEGINNER_C_PATTERN_SHEET/#i-arrays-pointers-connecting-the-concepts","title":"I. Arrays &amp; Pointers (Connecting the Concepts)","text":""},{"location":"BEGINNER_C_PATTERN_SHEET/#arrays-vs-pointers-practical-viewpoint","title":"Arrays vs Pointers (Practical Viewpoint)","text":"<p>Arrays:</p> <pre><code>int arr[5] = {1, 2, 3, 4, 5};\n// arr[0] = 1, arr[1] = 2, etc.\n</code></pre> <p>Pointers to arrays:</p> <pre><code>int arr[5] = {1, 2, 3, 4, 5};\nint *ptr = arr;  // Points to first element\n// ptr[0] = 1, ptr[1] = 2 (same as arr)\n</code></pre> <p>For strings:</p> <pre><code>char    *str = \"Hello\";  // str is a pointer\n// str[0] = 'H', str[1] = 'e', etc.\n</code></pre> <p>Key insight: Arrays and pointers work similarly for indexing. <code>arr[i]</code> and <code>ptr[i]</code> both work.</p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#indexing-patterns-youll-see","title":"Indexing Patterns You'll See","text":"<p>1. Sequential access:</p> <pre><code>int i = 0;\nwhile (i &lt; size)\n{\n    arr[i] = 0;  // Set each element to 0\n    i++;\n}\n</code></pre> <p>2. Reverse access:</p> <pre><code>int i = size - 1;  // Start from last element\nwhile (i &gt;= 0)\n{\n    arr[i] = 0;\n    i--;\n}\n</code></pre> <p>3. Pair swapping (from the repository):</p> <pre><code>int i = 0;\nwhile (i &lt; (size / 2))  // Only swap half\n{\n    temp = arr[size - 1 - i];  // Last element\n    arr[size - 1 - i] = arr[i];  // Move first to last\n    arr[i] = temp;  // Move last to first\n    i++;\n}\n</code></pre>"},{"location":"BEGINNER_C_PATTERN_SHEET/#j-output-debugging","title":"J. Output / Debugging","text":""},{"location":"BEGINNER_C_PATTERN_SHEET/#how-output-is-done-in-this-repository","title":"How Output Is Done in This Repository","text":"<p>Evidence: All output uses <code>write()</code>, never <code>printf()</code>.</p> <p><code>write()</code> function: What is <code>write()</code>? <code>write()</code> is a function that outputs data. It's the only output function you're allowed to use in 42 exercises (not <code>printf()</code>).</p> <pre><code>write(fd, buffer, count);\n// fd = file descriptor (1 = stdout/screen, 2 = stderr/error output)\n// buffer = what to write (address of data)\n// count = how many bytes to write\n</code></pre> <p>What is stdout? Stdout (standard output) is where your program normally prints - usually the screen/terminal.</p> <p>Examples from the repository:</p> <pre><code>write(1, &amp;c, 1);           // Write 1 character\nwrite(1, \"Hello\", 5);      // Write 5 characters\nwrite(1, \"\\n\", 1);         // Write newline\nwrite(1, \"-2147483648\", 11);  // Write 11 characters\n</code></pre> <p>Why <code>&amp;c</code> for single char? - <code>write()</code> needs an address, not the value - <code>&amp;c</code> gives address of <code>c</code> - For strings, the name is already an address: <code>\"Hello\"</code> or <code>str</code></p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#tiny-debugging-tricks","title":"Tiny Debugging Tricks","text":"<p>1. Print a character:</p> <pre><code>char    debug = 'X';\nwrite(1, &amp;debug, 1);  // See if code reaches here\n</code></pre> <p>2. Print a number (simple):</p> <pre><code>int n = 42;\nchar    c = n + '0';  // Only works for 0-9!\nwrite(1, &amp;c, 1);\n</code></pre> <p>3. Print a string marker:</p> <pre><code>write(1, \"DEBUG: reached here\\n\", 20);\n</code></pre>"},{"location":"BEGINNER_C_PATTERN_SHEET/#k-common-patterns-index","title":"K. Common Patterns Index","text":"<p>The core of this sheet. Quick lookup for reusable code patterns.</p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#pattern-iterate-string","title":"Pattern: Iterate String","text":"<p>When to use: Process each character in a string.</p> <p>Template:</p> <pre><code>int i;\n\ni = 0;\nwhile (str[i] != '\\0')\n{\n    // Process str[i]\n    i++;\n}\n</code></pre> <p>Pitfalls: - Forgetting <code>i++</code> \u2192 infinite loop - Not handling NULL pointer - Accessing <code>str[i]</code> after loop without checking</p> <p>Example: <code>c_01/ex05/ft_putstr.c:16-24</code></p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#pattern-copy-string","title":"Pattern: Copy String","text":"<p>When to use: Copy one string to another.</p> <p>Template:</p> <pre><code>int i;\n\ni = 0;\nwhile (src[i] != '\\0')\n{\n    dest[i] = src[i];\n    i++;\n}\ndest[i] = '\\0';  // CRITICAL: Add terminator!\n</code></pre> <p>Pitfalls: - Forgetting NUL terminator - No size check (buffer overflow risk) - Not handling NULL pointers</p> <p>Example: <code>c_02/ex00/ft_strcpy.c:19-26</code></p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#pattern-string-length","title":"Pattern: String Length","text":"<p>When to use: Count characters in string.</p> <p>Template:</p> <pre><code>int i;\n\ni = 0;\nwhile (str[i] != '\\0')\n    i++;\nreturn (i);  // Not i+1! (NUL not counted)\n</code></pre> <p>Pitfalls: - Returning <code>i + 1</code> (wrong - NUL not included in length) - Not handling NULL</p> <p>Example: <code>c_01/ex06/ft_strlen.c:14-24</code></p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#pattern-compare-strings","title":"Pattern: Compare Strings","text":"<p>When to use: Check if two strings are equal or compare lexicographically.</p> <p>Template:</p> <pre><code>while (*s1 == *s2 &amp;&amp; *s1 != '\\0')\n{\n    s1++;\n    s2++;\n}\nreturn (*s1 - *s2);  // Negative if s1 &lt; s2, 0 if equal, positive if s1 &gt; s2\n</code></pre> <p>Pitfalls: - Returning <code>s2 - s1</code> (wrong order) - Not handling NULL - Signed char overflow (rare)</p> <p>Example: <code>c_03/ex00/ft_strcmp.c:15-23</code></p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#pattern-swap-using-pointers","title":"Pattern: Swap (Using Pointers)","text":"<p>When to use: Exchange values of two variables.</p> <p>Template:</p> <pre><code>int temp;\n\ntemp = *a;\n*a = *b;\n*b = temp;\n</code></pre> <p>Pitfalls: - Forgetting temp variable - Wrong order of assignments - Forgetting <code>&amp;</code> when calling</p> <p>Example: <code>c_01/ex02/ft_swap.c:14-21</code></p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#pattern-reverse-array","title":"Pattern: Reverse Array","text":"<p>When to use: Reverse elements in array in-place.</p> <p>Template:</p> <pre><code>int i;\nint temp;\n\ni = 0;\nwhile (i &lt; (size / 2))  // Only swap half\n{\n    temp = arr[size - 1 - i];\n    arr[size - 1 - i] = arr[i];\n    arr[i] = temp;\n    i++;\n}\n</code></pre> <p>Pitfalls: - Using <code>i &lt;= size / 2</code> (double-swaps middle if odd) - Wrong index calculation</p> <p>Example: <code>c_01/ex07/ft_rev_int_tab.c:14-27</code></p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#pattern-character-classification","title":"Pattern: Character Classification","text":"<p>When to use: Check if character is letter, digit, etc. (can't use <code>isalpha()</code>).</p> <p>Template:</p> <pre><code>// Check if lowercase\nif (c &gt;= 'a' &amp;&amp; c &lt;= 'z')\n    return (1);\n\n// Check if uppercase\nif (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')\n    return (1);\n\n// Check if digit\nif (c &gt;= '0' &amp;&amp; c &lt;= '9')\n    return (1);\n</code></pre> <p>Pitfalls: - Using magic numbers instead of characters (<code>97</code> vs <code>'a'</code>) - Wrong ranges (off-by-one)</p> <p>Example: <code>c_02/ex02/ft_str_is_alpha.c:22</code></p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#pattern-case-conversion","title":"Pattern: Case Conversion","text":"<p>When to use: Convert letter to uppercase or lowercase.</p> <p>Template:</p> <pre><code>// To uppercase\nif (c &gt;= 'a' &amp;&amp; c &lt;= 'z')\n    c = c - 32;  // Or: c = c - ('a' - 'A')\n\n// To lowercase\nif (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')\n    c = c + 32;  // Or: c = c + ('a' - 'A')\n</code></pre> <p>Why: ASCII difference between 'a' and 'A' is 32.</p> <p>Pitfalls: - Modifying non-letters - Wrong direction (+ vs -)</p> <p>Example: <code>c_02/ex07/ft_strupcase.c:19-27</code></p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#pattern-print-number","title":"Pattern: Print Number","text":"<p>When to use: Print integer using only <code>write()</code> (no <code>printf()</code>).</p> <p>Template:</p> <pre><code>void    ft_putchar(char c)\n{\n    write(1, &amp;c, 1);\n}\n\nvoid    ft_putnbr(int nb)\n{\n    if (nb == -2147483648)  // INT_MIN special case\n    {\n        write(1, \"-2147483648\", 11);\n        return;\n    }\n    if (nb &lt; 0)\n    {\n        write(1, \"-\", 1);\n        nb = -nb;\n    }\n    if (nb &gt;= 10)\n    {\n        ft_putnbr(nb / 10);  // Recursive: print higher digits\n        ft_putchar((nb % 10) + '0');  // Print last digit\n    }\n    else\n        ft_putchar(nb + '0');\n}\n</code></pre> <p>Pitfalls: - Forgetting INT_MIN case \u2192 overflow - Not converting digit to char (<code>+ '0'</code>)</p> <p>Example: <code>c_00/ex07/ft_putnbr.c:19-40</code></p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#quick-reference-ascii-values","title":"Quick Reference: ASCII Values","text":"Character Decimal Use Case <code>'0'</code> 48 Digits start <code>'9'</code> 57 Digits end <code>'A'</code> 65 Uppercase start <code>'Z'</code> 90 Uppercase end <code>'a'</code> 97 Lowercase start <code>'z'</code> 122 Lowercase end <code>' '</code> 32 Space (first printable) <code>'\\0'</code> 0 String terminator <code>'\\n'</code> 10 Newline <p>Case conversion: <code>'a' - 'A' = 32</code> (add 32 for lowercase, subtract for uppercase)</p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#quick-reference-common-mistakes-checklist","title":"Quick Reference: Common Mistakes Checklist","text":"<p>Before submitting, check:</p> <ul> <li>[ ] All strings null-terminated? (<code>dest[i] = '\\0'</code>)</li> <li>[ ] Loop variables incremented? (<code>i++</code> inside loop)</li> <li>[ ] Array bounds checked? (<code>i &lt; size</code> not <code>i &lt;= size</code>)</li> <li>[ ] Pointers: Used <code>&amp;</code> when passing address? (<code>func(&amp;x)</code> not <code>func(x)</code>)</li> <li>[ ] Pointers: Used <code>*</code> when dereferencing? (<code>*ptr = 5</code> not <code>ptr = 5</code>)</li> <li>[ ] NULL pointers handled? (if required)</li> <li>[ ] Division by zero checked? (if dividing)</li> <li>[ ] INT_MIN handled? (if negating integers)</li> <li>[ ] Return statement present? (if function returns value)</li> <li>[ ] Correct return type? (<code>int</code> vs <code>char*</code> vs <code>void</code>)</li> <li>[ ] Includes correct? (<code>&lt;unistd.h&gt;</code> for <code>write()</code>)</li> <li>[ ] Header format correct? (42 style)</li> </ul>"},{"location":"BEGINNER_C_PATTERN_SHEET/#l-next-steps-header-files-advanced","title":"L. Next Steps: Header Files (Advanced)","text":"<p>Skip this section for your first 2 weeks. Come back later!</p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#what-goes-in-a-h-file","title":"What Goes in a <code>.h</code> File","text":"<p>What is a <code>.h</code> file? A header file (<code>.h</code> file) contains function declarations (not the actual code, just the signatures). It's used when you have multiple files that need to share functions.</p> <p>Evidence from repository: No <code>.h</code> files found in early exercises. When you'll need it: Later projects (libft, etc.) when you have multiple files.</p> <p>Typical structure:</p> <pre><code>#ifndef FT_EXAMPLE_H\n# define FT_EXAMPLE_H\n\nvoid    ft_function_name(int param);\n\n#endif\n</code></pre> <p>Purpose: - Declare function prototypes (so other files know what functions exist) - Share constants, types, etc. - Include in <code>.c</code> files: <code>#include \"ft_example.h\"</code></p> <p>What is a function prototype? A function prototype is a declaration that tells the compiler a function exists, what it returns, and what parameters it takes - without showing the actual code.</p> <p>Note: For now, focus on single-file exercises. Headers come later!</p> <p>Last tip: When stuck, look for similar patterns in the repository. Most exercises reuse the same building blocks!</p>"},{"location":"BEGINNER_C_PATTERN_SHEET/#need-help-check-the-glossary","title":"\ud83d\udcd6 Need Help? Check the Glossary","text":"<p>If you encounter any term you don't understand, scroll back to the Quick Lexicon (Glossary) section at the beginning of this document. All technical terms are defined there, and many are also explained inline when first introduced.</p> <p>Remember: Learning to program takes practice. Don't be discouraged if concepts don't click immediately. Keep coding, keep referring to this guide, and you'll get it!</p>"}]}